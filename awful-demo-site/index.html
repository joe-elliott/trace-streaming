<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Go WebSocket Tutorial</title>
  </head>
  <body>
    <h2>Let's goooo!</h2>
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <script>
       const maxTraces = 50
       let traces = []

        let socket = new WebSocket("ws://127.0.0.1:31235/socket");
        console.log("Attempting Connection...");

        socket.onopen = () => {
            console.log("Successfully Connected");
            socket.send("Hi From the Client!")
        };
        
        socket.onclose = event => {
            console.log("Socket Closed Connection: ", event);
            socket.send("Client Closed!")
        };

        socket.onerror = error => {
            console.log("Socket Error: ", error);
        };

        socket.onmessage = msg => {
            console.log("Message: ", msg)

            if (msg.data != "{}") {
              traces.push(JSON.parse(msg.data).spans)
              if (traces.length > maxTraces) traces.pop()
              
              makeTree(traces)
            }
        }
    </script>
    <script>
      function makeTree(traces) {
        allSpans = traces.flat()

        rootSpan = {
          spanID : "root",
          processName : "root",
          operationName : "root",
          parentSpanID : "",
          duration: 0,
        }
        allSpans.push(rootSpan)
        
        var data = d3.stratify()
                      .id(function(d) { return d.spanID })
                      .parentId(function(d) { return "parentSpanID" in d ? d.parentSpanID : "root" })
                      (allSpans)

        collapse(data)

        var root = d3.hierarchy(data)
             .sum(d => 'children' in d ? d.value : 0)

        width = 932
        height = 1200

        color = d3.scaleOrdinal(d3.schemePaired)
        format = d3.format(",d")

        root.each(d => d.data.name = d.data.data.processName + "-" + d.data.data.operationName)

        root = d3.partition()
            .size([height, width])
            .padding(1)
            (root)        
        
        d3.select("body svg").remove();
        const svg = d3.select("body").append("svg")
                    .style("width", "100%")
                    .style("height", height)
                    .style("font", "10px sans-serif");

        const cell = svg
          .selectAll("g")
          .data(root.descendants())
          .join("g")
            .attr("transform", d => `translate(${d.y0},${d.x0})`);

        cell.append("rect")
            .attr("width", d => d.y1 - d.y0)
            .attr("height", d => d.x1 - d.x0)
            .attr("fill-opacity", 0.6)
            .attr("fill", d => {
              if (!d.depth) return "#ccc";
              return color(d.data.data.processName);
            });

        const text = cell.filter(d => (d.x1 - d.x0) > 16).append("text")
            .attr("x", 4)
            .attr("y", 13);

        text.append("tspan")
            .text(d => d.data.name);

        text.append("tspan")
            .attr("fill-opacity", 0.7)
            .text(d => ` ${format(d.value)}`);

        cell.append("title")
            .text(d => `${d.ancestors().map(d => d.data.name).reverse().join("/")}\n${format(d.value)}`);
      }

      function collapse(node) {
        if(!("children" in node)) {
          return
        }

        agg = new Map()

        node.children.forEach( c => {
            c.value = 1
            name = c.data.processName + "-" + c.data.operationName

            if (agg.has(name)) {
              merge(agg.get(name), c)
            } else {
              agg.set(name, c)
            }
        })

        node.children = Array.from(agg.values())

        node.children.forEach(c => collapse(c))
      }

      function merge(n1, n2) {
        all = []
        if (n1.children) n1.children.forEach(c => {all.push(c)})
        if (n2.children) n2.children.forEach(c => {all.push(c)})
        all.forEach(c => c.parent = n1)
        n1.children = all

        value = 0
        value += n1.value ? n1.value : 1
        value += n2.value ? n2.value : 1
        n1.value = value        
      }
    </script>
  </body>
</html>