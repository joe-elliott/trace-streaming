// Code generated by protoc-gen-go. DO NOT EDIT.
// source: stream.proto

/*
Package streampb is a generated protocol buffer package.

It is generated from these files:
	stream.proto

It has these top-level messages:
	StreamRequest
	TraceRequest
	SpanRequest
	SpanResponse
	Span
	Process
	KeyValuePair
	Status
*/
package streampb

import (
	fmt "fmt"

	proto "github.com/golang/protobuf/proto"

	math "math"

	context "golang.org/x/net/context"

	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type KeyValuePair_ValueType int32

const (
	KeyValuePair_STRING KeyValuePair_ValueType = 0
	KeyValuePair_INT    KeyValuePair_ValueType = 1
	KeyValuePair_DOUBLE KeyValuePair_ValueType = 2
	KeyValuePair_BOOL   KeyValuePair_ValueType = 3
)

var KeyValuePair_ValueType_name = map[int32]string{
	0: "STRING",
	1: "INT",
	2: "DOUBLE",
	3: "BOOL",
}
var KeyValuePair_ValueType_value = map[string]int32{
	"STRING": 0,
	"INT":    1,
	"DOUBLE": 2,
	"BOOL":   3,
}

func (x KeyValuePair_ValueType) String() string {
	return proto.EnumName(KeyValuePair_ValueType_name, int32(x))
}
func (KeyValuePair_ValueType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{6, 0} }

type Status_StatusCode int32

const (
	Status_Ok                 Status_StatusCode = 0
	Status_Cancelled          Status_StatusCode = 1
	Status_UnknownError       Status_StatusCode = 2
	Status_InvalidArgument    Status_StatusCode = 3
	Status_DeadlineExceeded   Status_StatusCode = 4
	Status_NotFound           Status_StatusCode = 5
	Status_AlreadyExists      Status_StatusCode = 6
	Status_PermissionDenied   Status_StatusCode = 7
	Status_ResourceExhausted  Status_StatusCode = 8
	Status_FailedPrecondition Status_StatusCode = 9
	Status_Aborted            Status_StatusCode = 10
	Status_OutOfRange         Status_StatusCode = 11
	Status_Unimplemented      Status_StatusCode = 12
	Status_InternalError      Status_StatusCode = 13
	Status_Unavailable        Status_StatusCode = 14
	Status_DataLoss           Status_StatusCode = 15
	Status_Unauthenticated    Status_StatusCode = 16
)

var Status_StatusCode_name = map[int32]string{
	0:  "Ok",
	1:  "Cancelled",
	2:  "UnknownError",
	3:  "InvalidArgument",
	4:  "DeadlineExceeded",
	5:  "NotFound",
	6:  "AlreadyExists",
	7:  "PermissionDenied",
	8:  "ResourceExhausted",
	9:  "FailedPrecondition",
	10: "Aborted",
	11: "OutOfRange",
	12: "Unimplemented",
	13: "InternalError",
	14: "Unavailable",
	15: "DataLoss",
	16: "Unauthenticated",
}
var Status_StatusCode_value = map[string]int32{
	"Ok":                 0,
	"Cancelled":          1,
	"UnknownError":       2,
	"InvalidArgument":    3,
	"DeadlineExceeded":   4,
	"NotFound":           5,
	"AlreadyExists":      6,
	"PermissionDenied":   7,
	"ResourceExhausted":  8,
	"FailedPrecondition": 9,
	"Aborted":            10,
	"OutOfRange":         11,
	"Unimplemented":      12,
	"InternalError":      13,
	"Unavailable":        14,
	"DataLoss":           15,
	"Unauthenticated":    16,
}

func (x Status_StatusCode) String() string {
	return proto.EnumName(Status_StatusCode_name, int32(x))
}
func (Status_StatusCode) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{7, 0} }

type StreamRequest struct {
	RequestedBatchSize int32 `protobuf:"varint,1,opt,name=requestedBatchSize" json:"requestedBatchSize,omitempty"`
	RequestedRate      int32 `protobuf:"varint,2,opt,name=requestedRate" json:"requestedRate,omitempty"`
}

func (m *StreamRequest) Reset()                    { *m = StreamRequest{} }
func (m *StreamRequest) String() string            { return proto.CompactTextString(m) }
func (*StreamRequest) ProtoMessage()               {}
func (*StreamRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *StreamRequest) GetRequestedBatchSize() int32 {
	if m != nil {
		return m.RequestedBatchSize
	}
	return 0
}

func (m *StreamRequest) GetRequestedRate() int32 {
	if m != nil {
		return m.RequestedRate
	}
	return 0
}

type TraceRequest struct {
	Params      *StreamRequest `protobuf:"bytes,1,opt,name=params" json:"params,omitempty"`
	ProcessName string         `protobuf:"bytes,2,opt,name=ProcessName,json=processName" json:"ProcessName,omitempty"`
}

func (m *TraceRequest) Reset()                    { *m = TraceRequest{} }
func (m *TraceRequest) String() string            { return proto.CompactTextString(m) }
func (*TraceRequest) ProtoMessage()               {}
func (*TraceRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *TraceRequest) GetParams() *StreamRequest {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *TraceRequest) GetProcessName() string {
	if m != nil {
		return m.ProcessName
	}
	return ""
}

type SpanRequest struct {
	Params        *StreamRequest `protobuf:"bytes,1,opt,name=params" json:"params,omitempty"`
	OperationName string         `protobuf:"bytes,2,opt,name=OperationName,json=operationName" json:"OperationName,omitempty"`
	ProcessName   string         `protobuf:"bytes,3,opt,name=ProcessName,json=processName" json:"ProcessName,omitempty"`
	MinDuration   int32          `protobuf:"varint,4,opt,name=MinDuration,json=minDuration" json:"MinDuration,omitempty"`
}

func (m *SpanRequest) Reset()                    { *m = SpanRequest{} }
func (m *SpanRequest) String() string            { return proto.CompactTextString(m) }
func (*SpanRequest) ProtoMessage()               {}
func (*SpanRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *SpanRequest) GetParams() *StreamRequest {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *SpanRequest) GetOperationName() string {
	if m != nil {
		return m.OperationName
	}
	return ""
}

func (m *SpanRequest) GetProcessName() string {
	if m != nil {
		return m.ProcessName
	}
	return ""
}

func (m *SpanRequest) GetMinDuration() int32 {
	if m != nil {
		return m.MinDuration
	}
	return 0
}

type SpanResponse struct {
	Dropped int32   `protobuf:"varint,1,opt,name=dropped" json:"dropped,omitempty"`
	Spans   []*Span `protobuf:"bytes,2,rep,name=spans" json:"spans,omitempty"`
}

func (m *SpanResponse) Reset()                    { *m = SpanResponse{} }
func (m *SpanResponse) String() string            { return proto.CompactTextString(m) }
func (*SpanResponse) ProtoMessage()               {}
func (*SpanResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *SpanResponse) GetDropped() int32 {
	if m != nil {
		return m.Dropped
	}
	return 0
}

func (m *SpanResponse) GetSpans() []*Span {
	if m != nil {
		return m.Spans
	}
	return nil
}

type Span struct {
	TraceID      []byte                   `protobuf:"bytes,1,opt,name=traceID,proto3" json:"traceID,omitempty"`
	SpanID       []byte                   `protobuf:"bytes,2,opt,name=spanID,proto3" json:"spanID,omitempty"`
	ParentSpanID []byte                   `protobuf:"bytes,3,opt,name=parentSpanID,proto3" json:"parentSpanID,omitempty"`
	Name         string                   `protobuf:"bytes,5,opt,name=name" json:"name,omitempty"`
	StartTime    int64                    `protobuf:"varint,6,opt,name=startTime" json:"startTime,omitempty"`
	Duration     int32                    `protobuf:"varint,7,opt,name=duration" json:"duration,omitempty"`
	Status       *Status                  `protobuf:"bytes,8,opt,name=status" json:"status,omitempty"`
	Events       map[string]*KeyValuePair `protobuf:"bytes,9,rep,name=events" json:"events,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Attributes   map[string]*KeyValuePair `protobuf:"bytes,10,rep,name=attributes" json:"attributes,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Process      *Process                 `protobuf:"bytes,11,opt,name=process" json:"process,omitempty"`
	ParentIndex  int32                    `protobuf:"varint,12,opt,name=parentIndex" json:"parentIndex,omitempty"`
}

func (m *Span) Reset()                    { *m = Span{} }
func (m *Span) String() string            { return proto.CompactTextString(m) }
func (*Span) ProtoMessage()               {}
func (*Span) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *Span) GetTraceID() []byte {
	if m != nil {
		return m.TraceID
	}
	return nil
}

func (m *Span) GetSpanID() []byte {
	if m != nil {
		return m.SpanID
	}
	return nil
}

func (m *Span) GetParentSpanID() []byte {
	if m != nil {
		return m.ParentSpanID
	}
	return nil
}

func (m *Span) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Span) GetStartTime() int64 {
	if m != nil {
		return m.StartTime
	}
	return 0
}

func (m *Span) GetDuration() int32 {
	if m != nil {
		return m.Duration
	}
	return 0
}

func (m *Span) GetStatus() *Status {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *Span) GetEvents() map[string]*KeyValuePair {
	if m != nil {
		return m.Events
	}
	return nil
}

func (m *Span) GetAttributes() map[string]*KeyValuePair {
	if m != nil {
		return m.Attributes
	}
	return nil
}

func (m *Span) GetProcess() *Process {
	if m != nil {
		return m.Process
	}
	return nil
}

func (m *Span) GetParentIndex() int32 {
	if m != nil {
		return m.ParentIndex
	}
	return 0
}

type Process struct {
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
}

func (m *Process) Reset()                    { *m = Process{} }
func (m *Process) String() string            { return proto.CompactTextString(m) }
func (*Process) ProtoMessage()               {}
func (*Process) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *Process) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type KeyValuePair struct {
	Key  string                 `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	Type KeyValuePair_ValueType `protobuf:"varint,2,opt,name=type,enum=streampb.KeyValuePair_ValueType" json:"type,omitempty"`
	// Only one of the following fields is supposed to contain data (determined by `type` field).
	// This is deliberately not using Protobuf `oneof` for performance reasons (verified by benchmarks).
	StringValue string  `protobuf:"bytes,3,opt,name=string_value,json=stringValue" json:"string_value,omitempty"`
	IntValue    int64   `protobuf:"varint,4,opt,name=int_value,json=intValue" json:"int_value,omitempty"`
	DoubleValue float64 `protobuf:"fixed64,5,opt,name=double_value,json=doubleValue" json:"double_value,omitempty"`
	BoolValue   bool    `protobuf:"varint,6,opt,name=bool_value,json=boolValue" json:"bool_value,omitempty"`
}

func (m *KeyValuePair) Reset()                    { *m = KeyValuePair{} }
func (m *KeyValuePair) String() string            { return proto.CompactTextString(m) }
func (*KeyValuePair) ProtoMessage()               {}
func (*KeyValuePair) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *KeyValuePair) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *KeyValuePair) GetType() KeyValuePair_ValueType {
	if m != nil {
		return m.Type
	}
	return KeyValuePair_STRING
}

func (m *KeyValuePair) GetStringValue() string {
	if m != nil {
		return m.StringValue
	}
	return ""
}

func (m *KeyValuePair) GetIntValue() int64 {
	if m != nil {
		return m.IntValue
	}
	return 0
}

func (m *KeyValuePair) GetDoubleValue() float64 {
	if m != nil {
		return m.DoubleValue
	}
	return 0
}

func (m *KeyValuePair) GetBoolValue() bool {
	if m != nil {
		return m.BoolValue
	}
	return false
}

// The Status type defines a logical error model that is suitable for different
// programming environments, including REST APIs and RPC APIs.
type Status struct {
	Code    Status_StatusCode `protobuf:"varint,1,opt,name=code,enum=streampb.Status_StatusCode" json:"code,omitempty"`
	Message string            `protobuf:"bytes,2,opt,name=message" json:"message,omitempty"`
}

func (m *Status) Reset()                    { *m = Status{} }
func (m *Status) String() string            { return proto.CompactTextString(m) }
func (*Status) ProtoMessage()               {}
func (*Status) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *Status) GetCode() Status_StatusCode {
	if m != nil {
		return m.Code
	}
	return Status_Ok
}

func (m *Status) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func init() {
	proto.RegisterType((*StreamRequest)(nil), "streampb.StreamRequest")
	proto.RegisterType((*TraceRequest)(nil), "streampb.TraceRequest")
	proto.RegisterType((*SpanRequest)(nil), "streampb.SpanRequest")
	proto.RegisterType((*SpanResponse)(nil), "streampb.SpanResponse")
	proto.RegisterType((*Span)(nil), "streampb.Span")
	proto.RegisterType((*Process)(nil), "streampb.Process")
	proto.RegisterType((*KeyValuePair)(nil), "streampb.KeyValuePair")
	proto.RegisterType((*Status)(nil), "streampb.Status")
	proto.RegisterEnum("streampb.KeyValuePair_ValueType", KeyValuePair_ValueType_name, KeyValuePair_ValueType_value)
	proto.RegisterEnum("streampb.Status_StatusCode", Status_StatusCode_name, Status_StatusCode_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for SpanStream service

type SpanStreamClient interface {
	QuerySpans(ctx context.Context, in *SpanRequest, opts ...grpc.CallOption) (SpanStream_QuerySpansClient, error)
	QueryTraces(ctx context.Context, in *TraceRequest, opts ...grpc.CallOption) (SpanStream_QueryTracesClient, error)
}

type spanStreamClient struct {
	cc *grpc.ClientConn
}

func NewSpanStreamClient(cc *grpc.ClientConn) SpanStreamClient {
	return &spanStreamClient{cc}
}

func (c *spanStreamClient) QuerySpans(ctx context.Context, in *SpanRequest, opts ...grpc.CallOption) (SpanStream_QuerySpansClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_SpanStream_serviceDesc.Streams[0], c.cc, "/streampb.SpanStream/QuerySpans", opts...)
	if err != nil {
		return nil, err
	}
	x := &spanStreamQuerySpansClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type SpanStream_QuerySpansClient interface {
	Recv() (*SpanResponse, error)
	grpc.ClientStream
}

type spanStreamQuerySpansClient struct {
	grpc.ClientStream
}

func (x *spanStreamQuerySpansClient) Recv() (*SpanResponse, error) {
	m := new(SpanResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *spanStreamClient) QueryTraces(ctx context.Context, in *TraceRequest, opts ...grpc.CallOption) (SpanStream_QueryTracesClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_SpanStream_serviceDesc.Streams[1], c.cc, "/streampb.SpanStream/QueryTraces", opts...)
	if err != nil {
		return nil, err
	}
	x := &spanStreamQueryTracesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type SpanStream_QueryTracesClient interface {
	Recv() (*SpanResponse, error)
	grpc.ClientStream
}

type spanStreamQueryTracesClient struct {
	grpc.ClientStream
}

func (x *spanStreamQueryTracesClient) Recv() (*SpanResponse, error) {
	m := new(SpanResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for SpanStream service

type SpanStreamServer interface {
	QuerySpans(*SpanRequest, SpanStream_QuerySpansServer) error
	QueryTraces(*TraceRequest, SpanStream_QueryTracesServer) error
}

func RegisterSpanStreamServer(s *grpc.Server, srv SpanStreamServer) {
	s.RegisterService(&_SpanStream_serviceDesc, srv)
}

func _SpanStream_QuerySpans_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SpanRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(SpanStreamServer).QuerySpans(m, &spanStreamQuerySpansServer{stream})
}

type SpanStream_QuerySpansServer interface {
	Send(*SpanResponse) error
	grpc.ServerStream
}

type spanStreamQuerySpansServer struct {
	grpc.ServerStream
}

func (x *spanStreamQuerySpansServer) Send(m *SpanResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _SpanStream_QueryTraces_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(TraceRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(SpanStreamServer).QueryTraces(m, &spanStreamQueryTracesServer{stream})
}

type SpanStream_QueryTracesServer interface {
	Send(*SpanResponse) error
	grpc.ServerStream
}

type spanStreamQueryTracesServer struct {
	grpc.ServerStream
}

func (x *spanStreamQueryTracesServer) Send(m *SpanResponse) error {
	return x.ServerStream.SendMsg(m)
}

var _SpanStream_serviceDesc = grpc.ServiceDesc{
	ServiceName: "streampb.SpanStream",
	HandlerType: (*SpanStreamServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "QuerySpans",
			Handler:       _SpanStream_QuerySpans_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "QueryTraces",
			Handler:       _SpanStream_QueryTraces_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "stream.proto",
}

func init() { proto.RegisterFile("stream.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 949 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x55, 0xdd, 0x6e, 0xe3, 0x44,
	0x14, 0xae, 0x93, 0x34, 0x3f, 0xc7, 0x4e, 0x3b, 0x3d, 0xb0, 0xc5, 0xea, 0xb2, 0xa8, 0x6b, 0xf5,
	0xa2, 0x12, 0x28, 0x8b, 0x02, 0x42, 0x88, 0x0b, 0x50, 0xbb, 0xc9, 0xa2, 0x88, 0xd2, 0x74, 0xdd,
	0x86, 0x5b, 0x34, 0x89, 0x0f, 0xad, 0x55, 0x67, 0x6c, 0x66, 0xc6, 0xa5, 0xe1, 0x29, 0x56, 0xe2,
	0x25, 0x78, 0x09, 0x2e, 0x78, 0x33, 0x34, 0x33, 0x4e, 0x93, 0x86, 0x8a, 0x0b, 0xb4, 0x57, 0x9e,
	0xf3, 0x9d, 0xef, 0xfc, 0x7c, 0x73, 0xc6, 0x33, 0x10, 0x28, 0x2d, 0x89, 0xcf, 0x7b, 0x85, 0xcc,
	0x75, 0x8e, 0x6d, 0x67, 0x15, 0xd3, 0x88, 0xa0, 0x7b, 0x69, 0xd7, 0x31, 0xfd, 0x5a, 0x92, 0xd2,
	0xd8, 0x03, 0x94, 0x6e, 0x49, 0xc9, 0x29, 0xd7, 0xb3, 0x9b, 0xcb, 0xf4, 0x77, 0x0a, 0xbd, 0x43,
	0xef, 0x78, 0x3b, 0x7e, 0xc2, 0x83, 0x47, 0xd0, 0x7d, 0x40, 0x63, 0xae, 0x29, 0xac, 0x59, 0xea,
	0x63, 0x30, 0xe2, 0x10, 0x5c, 0x49, 0x3e, 0xa3, 0x65, 0x95, 0x57, 0xd0, 0x2c, 0xb8, 0xe4, 0x73,
	0x65, 0x33, 0xfb, 0xfd, 0x8f, 0x7a, 0xcb, 0x8e, 0x7a, 0x8f, 0xda, 0x89, 0x2b, 0x1a, 0x1e, 0x82,
	0x7f, 0x21, 0xf3, 0x19, 0x29, 0x75, 0xce, 0xe7, 0xae, 0x48, 0x27, 0xf6, 0x8b, 0x15, 0x14, 0xfd,
	0xe9, 0x81, 0x7f, 0x59, 0x70, 0xf1, 0xbf, 0x4b, 0x1c, 0x41, 0x77, 0x5c, 0x90, 0xe4, 0x3a, 0xcd,
	0xc5, 0x5a, 0x91, 0x6e, 0xbe, 0x0e, 0x6e, 0x36, 0x52, 0xff, 0x57, 0x23, 0x86, 0xf1, 0x63, 0x2a,
	0x06, 0xa5, 0x0b, 0x0a, 0x1b, 0x76, 0x3f, 0xfc, 0xf9, 0x0a, 0x8a, 0xce, 0x21, 0x70, 0x9d, 0xaa,
	0x22, 0x17, 0x8a, 0x30, 0x84, 0x56, 0x22, 0xf3, 0xa2, 0xa0, 0xa4, 0xda, 0xe8, 0xa5, 0x89, 0x47,
	0xb0, 0xad, 0x0a, 0x2e, 0x54, 0x58, 0x3b, 0xac, 0x1f, 0xfb, 0xfd, 0x9d, 0x35, 0x0d, 0x26, 0x81,
	0x73, 0x46, 0x7f, 0x37, 0xa0, 0x61, 0x6c, 0x93, 0x48, 0x9b, 0x6d, 0x1e, 0x0d, 0x6c, 0xa2, 0x20,
	0x5e, 0x9a, 0xb8, 0x0f, 0x4d, 0xc3, 0x1d, 0x0d, 0xac, 0xaa, 0x20, 0xae, 0x2c, 0x8c, 0x20, 0x28,
	0xb8, 0x24, 0xa1, 0x2f, 0x9d, 0xb7, 0x6e, 0xbd, 0x8f, 0x30, 0x44, 0x68, 0x08, 0xa3, 0x75, 0xdb,
	0x6a, 0xb5, 0x6b, 0xfc, 0x18, 0x3a, 0x4a, 0x73, 0xa9, 0xaf, 0xd2, 0x39, 0x85, 0xcd, 0x43, 0xef,
	0xb8, 0x1e, 0xaf, 0x00, 0x3c, 0x80, 0x76, 0xb2, 0xd4, 0xdf, 0xb2, 0x8a, 0x1e, 0x6c, 0x3c, 0x86,
	0xa6, 0xd2, 0x5c, 0x97, 0x2a, 0x6c, 0xdb, 0xb9, 0xb0, 0xf5, 0xb9, 0x18, 0x3c, 0xae, 0xfc, 0xd8,
	0x87, 0x26, 0xdd, 0x91, 0xd0, 0x2a, 0xec, 0x58, 0xf5, 0x07, 0x8f, 0xd5, 0xf7, 0x86, 0xd6, 0x39,
	0x14, 0x5a, 0x2e, 0xe2, 0x8a, 0x89, 0xdf, 0x02, 0x70, 0xad, 0x65, 0x3a, 0x2d, 0x35, 0xa9, 0x10,
	0x6c, 0xdc, 0x27, 0x1b, 0x71, 0x27, 0x0f, 0x04, 0x17, 0xbb, 0x16, 0x81, 0x9f, 0x42, 0xab, 0x9a,
	0x65, 0xe8, 0xdb, 0xf6, 0xf6, 0x56, 0xc1, 0xd5, 0xdc, 0xe3, 0x25, 0xc3, 0x4c, 0xda, 0x6d, 0xd4,
	0x48, 0x24, 0x74, 0x1f, 0x06, 0x6e, 0xd2, 0x6b, 0xd0, 0xc1, 0x5b, 0xf0, 0xd7, 0xba, 0x44, 0x06,
	0xf5, 0x5b, 0x5a, 0xd8, 0xd9, 0x74, 0x62, 0xb3, 0xc4, 0xcf, 0x60, 0xfb, 0x8e, 0x67, 0xa5, 0x3b,
	0x6c, 0x7e, 0x7f, 0x7f, 0x55, 0xed, 0x07, 0x5a, 0xfc, 0x64, 0x3c, 0x17, 0x3c, 0x95, 0xb1, 0x23,
	0x7d, 0x53, 0xfb, 0xda, 0x3b, 0x98, 0xc0, 0xee, 0x86, 0x80, 0xf7, 0x91, 0x36, 0x7a, 0x01, 0xad,
	0x4a, 0xdf, 0xc3, 0xbc, 0xbd, 0xd5, 0xbc, 0xa3, 0x77, 0x35, 0x08, 0xd6, 0x43, 0x9f, 0xa8, 0xf9,
	0x25, 0x34, 0xf4, 0xa2, 0x70, 0x25, 0x77, 0xfa, 0x87, 0x4f, 0x97, 0xec, 0xd9, 0xd5, 0xd5, 0xa2,
	0xa0, 0xd8, 0xb2, 0xf1, 0xa5, 0xbd, 0x9a, 0x52, 0x71, 0xfd, 0xb3, 0x6b, 0xb8, 0xfa, 0xa1, 0x1c,
	0x66, 0xc9, 0xf8, 0x1c, 0x3a, 0xa9, 0xd0, 0x95, 0xbf, 0x61, 0xcf, 0x5a, 0x3b, 0x15, 0xda, 0x39,
	0x5f, 0x42, 0x90, 0xe4, 0xe5, 0x34, 0xa3, 0xca, 0x6f, 0x0e, 0xa9, 0x17, 0xfb, 0x0e, 0x73, 0x94,
	0x17, 0x00, 0xd3, 0x3c, 0xcf, 0x2a, 0x82, 0x39, 0xac, 0xed, 0xb8, 0x63, 0x10, 0xeb, 0x8e, 0xbe,
	0x82, 0xce, 0x43, 0x53, 0x08, 0xd0, 0xbc, 0xbc, 0x8a, 0x47, 0xe7, 0xdf, 0xb3, 0x2d, 0x6c, 0x41,
	0x7d, 0x74, 0x7e, 0xc5, 0x3c, 0x03, 0x0e, 0xc6, 0x93, 0xd3, 0xb3, 0x21, 0xab, 0x61, 0x1b, 0x1a,
	0xa7, 0xe3, 0xf1, 0x19, 0xab, 0x47, 0x7f, 0xd4, 0xa1, 0xe9, 0x4e, 0x2c, 0xbe, 0x82, 0xc6, 0x2c,
	0x4f, 0xdc, 0x8e, 0xed, 0xf4, 0x9f, 0x6f, 0x9e, 0xe8, 0xea, 0xf3, 0x3a, 0x4f, 0x28, 0xb6, 0x44,
	0xf3, 0xa3, 0xce, 0x49, 0x29, 0x7e, 0xbd, 0xbc, 0x65, 0x96, 0x66, 0xf4, 0x57, 0x0d, 0x60, 0x45,
	0xc7, 0x26, 0xd4, 0xc6, 0xb7, 0x6c, 0x0b, 0xbb, 0xd0, 0x79, 0xcd, 0xc5, 0x8c, 0xb2, 0x8c, 0x12,
	0xe6, 0x21, 0x83, 0x60, 0x22, 0x6e, 0x45, 0xfe, 0x9b, 0x18, 0x4a, 0x99, 0x4b, 0x56, 0xc3, 0x0f,
	0x60, 0x77, 0x24, 0xee, 0x78, 0x96, 0x26, 0x27, 0xf2, 0xba, 0x9c, 0x93, 0xd0, 0xac, 0x8e, 0x1f,
	0x02, 0x1b, 0x10, 0x4f, 0xb2, 0x54, 0xd0, 0xf0, 0x7e, 0x46, 0x94, 0x50, 0xc2, 0x1a, 0x18, 0x40,
	0xfb, 0x3c, 0xd7, 0x6f, 0xf2, 0x52, 0x24, 0x6c, 0x1b, 0xf7, 0xa0, 0x7b, 0x92, 0x49, 0xe2, 0xc9,
	0x62, 0x78, 0x9f, 0x2a, 0xad, 0x58, 0xd3, 0x84, 0x5d, 0x90, 0x9c, 0xa7, 0x4a, 0xa5, 0xb9, 0x18,
	0x90, 0x48, 0x29, 0x61, 0x2d, 0x7c, 0x06, 0x7b, 0x31, 0xa9, 0xbc, 0x94, 0x33, 0x1a, 0xde, 0xdf,
	0xf0, 0xd2, 0x5c, 0xee, 0xac, 0x8d, 0xfb, 0x80, 0x6f, 0x78, 0x9a, 0x51, 0x72, 0x21, 0x69, 0x96,
	0x8b, 0x24, 0x35, 0x7f, 0x39, 0xeb, 0xa0, 0x0f, 0xad, 0x93, 0x69, 0x2e, 0x0d, 0x09, 0x70, 0x07,
	0x60, 0x5c, 0xea, 0xf1, 0x2f, 0x31, 0x17, 0xd7, 0xc4, 0x7c, 0x53, 0x74, 0x22, 0xd2, 0x79, 0x91,
	0x91, 0xe9, 0x94, 0x12, 0x16, 0x18, 0x68, 0x24, 0x34, 0x49, 0xc1, 0x33, 0xa7, 0xa9, 0x8b, 0xbb,
	0xe0, 0x4f, 0x04, 0xbf, 0xe3, 0x69, 0xc6, 0xa7, 0x19, 0xb1, 0x1d, 0xd3, 0xf9, 0x80, 0x6b, 0x7e,
	0x96, 0x2b, 0xc5, 0x76, 0x8d, 0xe4, 0x89, 0xe0, 0xa5, 0xbe, 0x21, 0xa1, 0xd3, 0x19, 0x37, 0x69,
	0x58, 0xff, 0x9d, 0x07, 0x60, 0xfe, 0x72, 0x77, 0xc7, 0xe3, 0x77, 0x00, 0x6f, 0x4b, 0x92, 0x0b,
	0x03, 0x29, 0x7c, 0xb6, 0x71, 0x7f, 0xba, 0x17, 0xe0, 0x60, 0x7f, 0x13, 0x76, 0xf7, 0x72, 0xb4,
	0xf5, 0xb9, 0x87, 0x27, 0xe0, 0xdb, 0x04, 0xf6, 0xf9, 0x52, 0xb8, 0x46, 0x5d, 0x7f, 0xd0, 0xfe,
	0x2b, 0xc5, 0xb4, 0x69, 0x1f, 0xdd, 0x2f, 0xfe, 0x09, 0x00, 0x00, 0xff, 0xff, 0x3b, 0xb2, 0x5d,
	0x08, 0x84, 0x07, 0x00, 0x00,
}
