// Code generated by protoc-gen-go. DO NOT EDIT.
// source: stream.proto

/*
Package streampb is a generated protocol buffer package.

It is generated from these files:
	stream.proto

It has these top-level messages:
	StreamRequest
	SpanResponse
	Span
	Metric
	Process
	KeyValuePair
	Status
*/
package streampb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type SpanResponse_ResponseType int32

const (
	SpanResponse_SPANS   SpanResponse_ResponseType = 0
	SpanResponse_METRICS SpanResponse_ResponseType = 1
	SpanResponse_TRACE   SpanResponse_ResponseType = 2
)

var SpanResponse_ResponseType_name = map[int32]string{
	0: "SPANS",
	1: "METRICS",
	2: "TRACE",
}
var SpanResponse_ResponseType_value = map[string]int32{
	"SPANS":   0,
	"METRICS": 1,
	"TRACE":   2,
}

func (x SpanResponse_ResponseType) String() string {
	return proto.EnumName(SpanResponse_ResponseType_name, int32(x))
}
func (SpanResponse_ResponseType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1, 0} }

type KeyValuePair_ValueType int32

const (
	KeyValuePair_STRING KeyValuePair_ValueType = 0
	KeyValuePair_INT    KeyValuePair_ValueType = 1
	KeyValuePair_DOUBLE KeyValuePair_ValueType = 2
	KeyValuePair_BOOL   KeyValuePair_ValueType = 3
)

var KeyValuePair_ValueType_name = map[int32]string{
	0: "STRING",
	1: "INT",
	2: "DOUBLE",
	3: "BOOL",
}
var KeyValuePair_ValueType_value = map[string]int32{
	"STRING": 0,
	"INT":    1,
	"DOUBLE": 2,
	"BOOL":   3,
}

func (x KeyValuePair_ValueType) String() string {
	return proto.EnumName(KeyValuePair_ValueType_name, int32(x))
}
func (KeyValuePair_ValueType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{5, 0} }

type Status_StatusCode int32

const (
	Status_Ok                 Status_StatusCode = 0
	Status_Cancelled          Status_StatusCode = 1
	Status_UnknownError       Status_StatusCode = 2
	Status_InvalidArgument    Status_StatusCode = 3
	Status_DeadlineExceeded   Status_StatusCode = 4
	Status_NotFound           Status_StatusCode = 5
	Status_AlreadyExists      Status_StatusCode = 6
	Status_PermissionDenied   Status_StatusCode = 7
	Status_ResourceExhausted  Status_StatusCode = 8
	Status_FailedPrecondition Status_StatusCode = 9
	Status_Aborted            Status_StatusCode = 10
	Status_OutOfRange         Status_StatusCode = 11
	Status_Unimplemented      Status_StatusCode = 12
	Status_InternalError      Status_StatusCode = 13
	Status_Unavailable        Status_StatusCode = 14
	Status_DataLoss           Status_StatusCode = 15
	Status_Unauthenticated    Status_StatusCode = 16
)

var Status_StatusCode_name = map[int32]string{
	0:  "Ok",
	1:  "Cancelled",
	2:  "UnknownError",
	3:  "InvalidArgument",
	4:  "DeadlineExceeded",
	5:  "NotFound",
	6:  "AlreadyExists",
	7:  "PermissionDenied",
	8:  "ResourceExhausted",
	9:  "FailedPrecondition",
	10: "Aborted",
	11: "OutOfRange",
	12: "Unimplemented",
	13: "InternalError",
	14: "Unavailable",
	15: "DataLoss",
	16: "Unauthenticated",
}
var Status_StatusCode_value = map[string]int32{
	"Ok":                 0,
	"Cancelled":          1,
	"UnknownError":       2,
	"InvalidArgument":    3,
	"DeadlineExceeded":   4,
	"NotFound":           5,
	"AlreadyExists":      6,
	"PermissionDenied":   7,
	"ResourceExhausted":  8,
	"FailedPrecondition": 9,
	"Aborted":            10,
	"OutOfRange":         11,
	"Unimplemented":      12,
	"InternalError":      13,
	"Unavailable":        14,
	"DataLoss":           15,
	"Unauthenticated":    16,
}

func (x Status_StatusCode) String() string {
	return proto.EnumName(Status_StatusCode_name, int32(x))
}
func (Status_StatusCode) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{6, 0} }

type StreamRequest struct {
	RequestedBatchSize int32  `protobuf:"varint,1,opt,name=requestedBatchSize" json:"requestedBatchSize,omitempty"`
	RequestedRate      int32  `protobuf:"varint,2,opt,name=requestedRate" json:"requestedRate,omitempty"`
	Query              string `protobuf:"bytes,3,opt,name=Query,json=query" json:"Query,omitempty"`
}

func (m *StreamRequest) Reset()                    { *m = StreamRequest{} }
func (m *StreamRequest) String() string            { return proto.CompactTextString(m) }
func (*StreamRequest) ProtoMessage()               {}
func (*StreamRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *StreamRequest) GetRequestedBatchSize() int32 {
	if m != nil {
		return m.RequestedBatchSize
	}
	return 0
}

func (m *StreamRequest) GetRequestedRate() int32 {
	if m != nil {
		return m.RequestedRate
	}
	return 0
}

func (m *StreamRequest) GetQuery() string {
	if m != nil {
		return m.Query
	}
	return ""
}

type SpanResponse struct {
	Dropped int32                     `protobuf:"varint,1,opt,name=dropped" json:"dropped,omitempty"`
	Type    SpanResponse_ResponseType `protobuf:"varint,2,opt,name=type,enum=streampb.SpanResponse_ResponseType" json:"type,omitempty"`
	Spans   []*Span                   `protobuf:"bytes,3,rep,name=spans" json:"spans,omitempty"`
	Metrics *Metric                   `protobuf:"bytes,4,opt,name=metrics" json:"metrics,omitempty"`
}

func (m *SpanResponse) Reset()                    { *m = SpanResponse{} }
func (m *SpanResponse) String() string            { return proto.CompactTextString(m) }
func (*SpanResponse) ProtoMessage()               {}
func (*SpanResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *SpanResponse) GetDropped() int32 {
	if m != nil {
		return m.Dropped
	}
	return 0
}

func (m *SpanResponse) GetType() SpanResponse_ResponseType {
	if m != nil {
		return m.Type
	}
	return SpanResponse_SPANS
}

func (m *SpanResponse) GetSpans() []*Span {
	if m != nil {
		return m.Spans
	}
	return nil
}

func (m *SpanResponse) GetMetrics() *Metric {
	if m != nil {
		return m.Metrics
	}
	return nil
}

type Span struct {
	TraceID      []byte                   `protobuf:"bytes,1,opt,name=traceID,proto3" json:"traceID,omitempty"`
	SpanID       []byte                   `protobuf:"bytes,2,opt,name=spanID,proto3" json:"spanID,omitempty"`
	ParentSpanID []byte                   `protobuf:"bytes,3,opt,name=parentSpanID,proto3" json:"parentSpanID,omitempty"`
	Name         string                   `protobuf:"bytes,5,opt,name=name" json:"name,omitempty"`
	StartTime    int64                    `protobuf:"varint,6,opt,name=startTime" json:"startTime,omitempty"`
	Duration     int32                    `protobuf:"varint,7,opt,name=duration" json:"duration,omitempty"`
	Status       *Status                  `protobuf:"bytes,8,opt,name=status" json:"status,omitempty"`
	Events       map[string]*KeyValuePair `protobuf:"bytes,9,rep,name=events" json:"events,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Attributes   map[string]*KeyValuePair `protobuf:"bytes,10,rep,name=attributes" json:"attributes,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Process      *Process                 `protobuf:"bytes,11,opt,name=process" json:"process,omitempty"`
	ParentIndex  int32                    `protobuf:"varint,12,opt,name=parentIndex" json:"parentIndex,omitempty"`
}

func (m *Span) Reset()                    { *m = Span{} }
func (m *Span) String() string            { return proto.CompactTextString(m) }
func (*Span) ProtoMessage()               {}
func (*Span) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *Span) GetTraceID() []byte {
	if m != nil {
		return m.TraceID
	}
	return nil
}

func (m *Span) GetSpanID() []byte {
	if m != nil {
		return m.SpanID
	}
	return nil
}

func (m *Span) GetParentSpanID() []byte {
	if m != nil {
		return m.ParentSpanID
	}
	return nil
}

func (m *Span) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Span) GetStartTime() int64 {
	if m != nil {
		return m.StartTime
	}
	return 0
}

func (m *Span) GetDuration() int32 {
	if m != nil {
		return m.Duration
	}
	return 0
}

func (m *Span) GetStatus() *Status {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *Span) GetEvents() map[string]*KeyValuePair {
	if m != nil {
		return m.Events
	}
	return nil
}

func (m *Span) GetAttributes() map[string]*KeyValuePair {
	if m != nil {
		return m.Attributes
	}
	return nil
}

func (m *Span) GetProcess() *Process {
	if m != nil {
		return m.Process
	}
	return nil
}

func (m *Span) GetParentIndex() int32 {
	if m != nil {
		return m.ParentIndex
	}
	return 0
}

type Metric struct {
	T int64     `protobuf:"varint,1,opt,name=t" json:"t,omitempty"`
	V []float64 `protobuf:"fixed64,2,rep,packed,name=v" json:"v,omitempty"`
}

func (m *Metric) Reset()                    { *m = Metric{} }
func (m *Metric) String() string            { return proto.CompactTextString(m) }
func (*Metric) ProtoMessage()               {}
func (*Metric) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *Metric) GetT() int64 {
	if m != nil {
		return m.T
	}
	return 0
}

func (m *Metric) GetV() []float64 {
	if m != nil {
		return m.V
	}
	return nil
}

type Process struct {
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
}

func (m *Process) Reset()                    { *m = Process{} }
func (m *Process) String() string            { return proto.CompactTextString(m) }
func (*Process) ProtoMessage()               {}
func (*Process) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *Process) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type KeyValuePair struct {
	Key  string                 `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	Type KeyValuePair_ValueType `protobuf:"varint,2,opt,name=type,enum=streampb.KeyValuePair_ValueType" json:"type,omitempty"`
	// Only one of the following fields is supposed to contain data (determined by `type` field).
	// This is deliberately not using Protobuf `oneof` for performance reasons (verified by benchmarks).
	StringValue string  `protobuf:"bytes,3,opt,name=string_value,json=stringValue" json:"string_value,omitempty"`
	IntValue    int64   `protobuf:"varint,4,opt,name=int_value,json=intValue" json:"int_value,omitempty"`
	DoubleValue float64 `protobuf:"fixed64,5,opt,name=double_value,json=doubleValue" json:"double_value,omitempty"`
	BoolValue   bool    `protobuf:"varint,6,opt,name=bool_value,json=boolValue" json:"bool_value,omitempty"`
}

func (m *KeyValuePair) Reset()                    { *m = KeyValuePair{} }
func (m *KeyValuePair) String() string            { return proto.CompactTextString(m) }
func (*KeyValuePair) ProtoMessage()               {}
func (*KeyValuePair) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *KeyValuePair) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *KeyValuePair) GetType() KeyValuePair_ValueType {
	if m != nil {
		return m.Type
	}
	return KeyValuePair_STRING
}

func (m *KeyValuePair) GetStringValue() string {
	if m != nil {
		return m.StringValue
	}
	return ""
}

func (m *KeyValuePair) GetIntValue() int64 {
	if m != nil {
		return m.IntValue
	}
	return 0
}

func (m *KeyValuePair) GetDoubleValue() float64 {
	if m != nil {
		return m.DoubleValue
	}
	return 0
}

func (m *KeyValuePair) GetBoolValue() bool {
	if m != nil {
		return m.BoolValue
	}
	return false
}

// The Status type defines a logical error model that is suitable for different
// programming environments, including REST APIs and RPC APIs.
type Status struct {
	Code    Status_StatusCode `protobuf:"varint,1,opt,name=code,enum=streampb.Status_StatusCode" json:"code,omitempty"`
	Message string            `protobuf:"bytes,2,opt,name=message" json:"message,omitempty"`
}

func (m *Status) Reset()                    { *m = Status{} }
func (m *Status) String() string            { return proto.CompactTextString(m) }
func (*Status) ProtoMessage()               {}
func (*Status) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *Status) GetCode() Status_StatusCode {
	if m != nil {
		return m.Code
	}
	return Status_Ok
}

func (m *Status) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func init() {
	proto.RegisterType((*StreamRequest)(nil), "streampb.StreamRequest")
	proto.RegisterType((*SpanResponse)(nil), "streampb.SpanResponse")
	proto.RegisterType((*Span)(nil), "streampb.Span")
	proto.RegisterType((*Metric)(nil), "streampb.Metric")
	proto.RegisterType((*Process)(nil), "streampb.Process")
	proto.RegisterType((*KeyValuePair)(nil), "streampb.KeyValuePair")
	proto.RegisterType((*Status)(nil), "streampb.Status")
	proto.RegisterEnum("streampb.SpanResponse_ResponseType", SpanResponse_ResponseType_name, SpanResponse_ResponseType_value)
	proto.RegisterEnum("streampb.KeyValuePair_ValueType", KeyValuePair_ValueType_name, KeyValuePair_ValueType_value)
	proto.RegisterEnum("streampb.Status_StatusCode", Status_StatusCode_name, Status_StatusCode_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for SpanStream service

type SpanStreamClient interface {
	Query(ctx context.Context, in *StreamRequest, opts ...grpc.CallOption) (SpanStream_QueryClient, error)
}

type spanStreamClient struct {
	cc *grpc.ClientConn
}

func NewSpanStreamClient(cc *grpc.ClientConn) SpanStreamClient {
	return &spanStreamClient{cc}
}

func (c *spanStreamClient) Query(ctx context.Context, in *StreamRequest, opts ...grpc.CallOption) (SpanStream_QueryClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_SpanStream_serviceDesc.Streams[0], c.cc, "/streampb.SpanStream/Query", opts...)
	if err != nil {
		return nil, err
	}
	x := &spanStreamQueryClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type SpanStream_QueryClient interface {
	Recv() (*SpanResponse, error)
	grpc.ClientStream
}

type spanStreamQueryClient struct {
	grpc.ClientStream
}

func (x *spanStreamQueryClient) Recv() (*SpanResponse, error) {
	m := new(SpanResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for SpanStream service

type SpanStreamServer interface {
	Query(*StreamRequest, SpanStream_QueryServer) error
}

func RegisterSpanStreamServer(s *grpc.Server, srv SpanStreamServer) {
	s.RegisterService(&_SpanStream_serviceDesc, srv)
}

func _SpanStream_Query_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(SpanStreamServer).Query(m, &spanStreamQueryServer{stream})
}

type SpanStream_QueryServer interface {
	Send(*SpanResponse) error
	grpc.ServerStream
}

type spanStreamQueryServer struct {
	grpc.ServerStream
}

func (x *spanStreamQueryServer) Send(m *SpanResponse) error {
	return x.ServerStream.SendMsg(m)
}

var _SpanStream_serviceDesc = grpc.ServiceDesc{
	ServiceName: "streampb.SpanStream",
	HandlerType: (*SpanStreamServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Query",
			Handler:       _SpanStream_Query_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "stream.proto",
}

func init() { proto.RegisterFile("stream.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 957 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x55, 0xdd, 0x6e, 0x23, 0x35,
	0x14, 0xee, 0x64, 0xf2, 0x7b, 0x32, 0x6d, 0x5d, 0xb3, 0x94, 0x51, 0x97, 0x45, 0xd9, 0xa1, 0x17,
	0x11, 0xa0, 0x00, 0x01, 0x01, 0x42, 0x08, 0x29, 0x6d, 0xb2, 0x28, 0xd0, 0x6d, 0xba, 0x4e, 0xc2,
	0x2d, 0x72, 0x32, 0x87, 0x76, 0xd4, 0x89, 0x67, 0xd6, 0xf6, 0x84, 0x06, 0x5e, 0x02, 0x89, 0xe7,
	0xe1, 0x82, 0x97, 0xe1, 0x39, 0x90, 0xed, 0xa4, 0x49, 0xab, 0x5e, 0x72, 0x35, 0x3e, 0xdf, 0xf7,
	0x1d, 0x9f, 0x9f, 0x39, 0xb6, 0x21, 0x50, 0x5a, 0x22, 0x5f, 0x74, 0x72, 0x99, 0xe9, 0x8c, 0xd6,
	0x9d, 0x95, 0xcf, 0xa2, 0x3f, 0x60, 0x7f, 0x6c, 0xd7, 0x0c, 0xdf, 0x16, 0xa8, 0x34, 0xed, 0x00,
	0x95, 0x6e, 0x89, 0xf1, 0x19, 0xd7, 0xf3, 0x9b, 0x71, 0xf2, 0x3b, 0x86, 0x5e, 0xcb, 0x6b, 0x57,
	0xd8, 0x13, 0x0c, 0x3d, 0x85, 0xfd, 0x7b, 0x94, 0x71, 0x8d, 0x61, 0xc9, 0x4a, 0x1f, 0x82, 0xf4,
	0x19, 0x54, 0xde, 0x14, 0x28, 0x57, 0xa1, 0xdf, 0xf2, 0xda, 0x0d, 0x56, 0x79, 0x6b, 0x8c, 0xe8,
	0x5f, 0x0f, 0x82, 0x71, 0xce, 0x05, 0x43, 0x95, 0x67, 0x42, 0x21, 0x0d, 0xa1, 0x16, 0xcb, 0x2c,
	0xcf, 0x31, 0x5e, 0x47, 0xdc, 0x98, 0xf4, 0x6b, 0x28, 0xeb, 0x55, 0xee, 0x76, 0x3f, 0xe8, 0x7e,
	0xd8, 0xd9, 0x14, 0xd0, 0xd9, 0xf5, 0xef, 0x6c, 0x16, 0x93, 0x55, 0x8e, 0xcc, 0x3a, 0xd0, 0x53,
	0xa8, 0xa8, 0x9c, 0x0b, 0x15, 0xfa, 0x2d, 0xbf, 0xdd, 0xec, 0x1e, 0x3c, 0xf2, 0x74, 0x24, 0xfd,
	0x08, 0x6a, 0x0b, 0xd4, 0x32, 0x99, 0xab, 0xb0, 0xdc, 0xf2, 0xda, 0xcd, 0x2e, 0xd9, 0xea, 0x5e,
	0x5b, 0x82, 0x6d, 0x04, 0xd1, 0xe7, 0x10, 0xec, 0xc6, 0xa1, 0x0d, 0xa8, 0x8c, 0xaf, 0x7a, 0x97,
	0x63, 0xb2, 0x47, 0x9b, 0x50, 0x7b, 0x3d, 0x98, 0xb0, 0xe1, 0xf9, 0x98, 0x78, 0x06, 0x9f, 0xb0,
	0xde, 0xf9, 0x80, 0x94, 0xa2, 0x7f, 0xca, 0x50, 0x36, 0xe1, 0x4c, 0x81, 0x5a, 0xf2, 0x39, 0x0e,
	0xfb, 0xb6, 0xc0, 0x80, 0x6d, 0x4c, 0x7a, 0x0c, 0x55, 0x93, 0xca, 0xb0, 0x6f, 0x4b, 0x0c, 0xd8,
	0xda, 0xa2, 0x11, 0x04, 0x39, 0x97, 0x28, 0xf4, 0xd8, 0xb1, 0xbe, 0x65, 0x1f, 0x60, 0x94, 0x42,
	0x59, 0xf0, 0x05, 0x86, 0x15, 0xdb, 0x5c, 0xbb, 0xa6, 0xef, 0x43, 0x43, 0x69, 0x2e, 0xf5, 0x24,
	0x59, 0x60, 0x58, 0x6d, 0x79, 0x6d, 0x9f, 0x6d, 0x01, 0x7a, 0x02, 0xf5, 0xb8, 0x90, 0x5c, 0x27,
	0x99, 0x08, 0x6b, 0xb6, 0xd3, 0xf7, 0x36, 0x6d, 0x43, 0x55, 0x69, 0xae, 0x0b, 0x15, 0xd6, 0x1f,
	0xb7, 0x62, 0x6c, 0x71, 0xb6, 0xe6, 0x69, 0x17, 0xaa, 0xb8, 0x44, 0xa1, 0x55, 0xd8, 0xb0, 0xcd,
	0x3d, 0x79, 0xd8, 0xdc, 0xce, 0xc0, 0x92, 0x03, 0xa1, 0xe5, 0x8a, 0xad, 0x95, 0xf4, 0x7b, 0x00,
	0xae, 0xb5, 0x4c, 0x66, 0x85, 0x46, 0x15, 0x82, 0xf5, 0xfb, 0xe0, 0x91, 0x5f, 0xef, 0x5e, 0xe0,
	0x7c, 0x77, 0x3c, 0xe8, 0xc7, 0x50, 0xcb, 0x65, 0x36, 0x47, 0xa5, 0xc2, 0xa6, 0x4d, 0xef, 0x68,
	0xeb, 0x7c, 0xe5, 0x08, 0xb6, 0x51, 0xd0, 0x16, 0x34, 0x5d, 0xa3, 0x86, 0x22, 0xc6, 0xbb, 0x30,
	0xb0, 0x95, 0xee, 0x42, 0x27, 0x6f, 0xa0, 0xb9, 0x93, 0x25, 0x25, 0xe0, 0xdf, 0xe2, 0xca, 0xfe,
	0x9b, 0x06, 0x33, 0x4b, 0xfa, 0x09, 0x54, 0x96, 0x3c, 0x2d, 0xdc, 0xe4, 0x35, 0xbb, 0xc7, 0xdb,
	0x68, 0x3f, 0xe1, 0xea, 0x67, 0xc3, 0x5c, 0xf1, 0x44, 0x32, 0x27, 0xfa, 0xb6, 0xf4, 0x8d, 0x77,
	0x32, 0x85, 0xc3, 0x47, 0x05, 0xfc, 0x1f, 0xdb, 0x46, 0xa7, 0x50, 0x75, 0x93, 0x48, 0x03, 0xf0,
	0xb4, 0xdd, 0xcb, 0x67, 0x9e, 0x36, 0xd6, 0x32, 0x2c, 0xb5, 0xfc, 0xb6, 0xc7, 0xbc, 0x65, 0xf4,
	0x02, 0x6a, 0xeb, 0x2e, 0xdc, 0x4f, 0x85, 0xb7, 0x9d, 0x8a, 0xe8, 0xcf, 0x12, 0x04, 0xbb, 0x01,
	0x9e, 0xc8, 0xec, 0xcb, 0x07, 0x27, 0xad, 0xf5, 0x74, 0x62, 0x1d, 0xbb, 0xda, 0x39, 0x66, 0x2f,
	0xed, 0x0d, 0x93, 0x88, 0xeb, 0x5f, 0x5c, 0x59, 0xee, 0x9c, 0x37, 0x1d, 0x66, 0xc5, 0xf4, 0x39,
	0x34, 0x12, 0xa1, 0xd7, 0x7c, 0xd9, 0xa6, 0x5f, 0x4f, 0x84, 0x76, 0xe4, 0x4b, 0x08, 0xe2, 0xac,
	0x98, 0xa5, 0xb8, 0xe6, 0xcd, 0x28, 0x7b, 0xac, 0xe9, 0x30, 0x27, 0x79, 0x01, 0x30, 0xcb, 0xb2,
	0x74, 0x2d, 0x30, 0x23, 0x5d, 0x67, 0x0d, 0x83, 0x58, 0x3a, 0xfa, 0x0a, 0x1a, 0xf7, 0x49, 0x51,
	0x80, 0xea, 0x78, 0xc2, 0x86, 0x97, 0x3f, 0x90, 0x3d, 0x5a, 0x03, 0x7f, 0x78, 0x39, 0x21, 0x9e,
	0x01, 0xfb, 0xa3, 0xe9, 0xd9, 0xc5, 0x80, 0x94, 0x68, 0x1d, 0xca, 0x67, 0xa3, 0xd1, 0x05, 0xf1,
	0xa3, 0xbf, 0x7c, 0xa8, 0xba, 0xb9, 0xa6, 0x9f, 0x42, 0x79, 0x9e, 0xc5, 0xae, 0x63, 0x07, 0xdd,
	0xe7, 0x8f, 0xe7, 0x7e, 0xfd, 0x39, 0xcf, 0x62, 0x64, 0x56, 0x68, 0x8e, 0xf3, 0x02, 0x95, 0xe2,
	0xd7, 0xae, 0x5d, 0x0d, 0xb6, 0x31, 0xa3, 0xbf, 0x4b, 0x00, 0x5b, 0x39, 0xad, 0x42, 0x69, 0x74,
	0x4b, 0xf6, 0xe8, 0x3e, 0x34, 0xce, 0xb9, 0x98, 0x63, 0x9a, 0x62, 0x4c, 0x3c, 0x4a, 0x20, 0x98,
	0x8a, 0x5b, 0x91, 0xfd, 0x26, 0x06, 0x52, 0x66, 0x92, 0x94, 0xe8, 0x3b, 0x70, 0x38, 0x14, 0x4b,
	0x9e, 0x26, 0x71, 0x4f, 0x5e, 0x17, 0x0b, 0x14, 0x9a, 0xf8, 0xf4, 0x19, 0x90, 0x3e, 0xf2, 0x38,
	0x4d, 0x04, 0x0e, 0xee, 0xe6, 0x88, 0x31, 0xc6, 0xa4, 0x4c, 0x03, 0xa8, 0x5f, 0x66, 0xfa, 0x55,
	0x56, 0x88, 0x98, 0x54, 0xe8, 0x11, 0xec, 0xf7, 0x52, 0x89, 0x3c, 0x5e, 0x0d, 0xee, 0x12, 0xa5,
	0x15, 0xa9, 0x1a, 0xb7, 0x2b, 0x94, 0x8b, 0x44, 0xa9, 0x24, 0x13, 0x7d, 0x14, 0x09, 0xc6, 0xa4,
	0x46, 0xdf, 0x85, 0x23, 0x86, 0x2a, 0x2b, 0xe4, 0x1c, 0x07, 0x77, 0x37, 0xbc, 0x30, 0x77, 0x34,
	0xa9, 0xd3, 0x63, 0xa0, 0xaf, 0x78, 0x92, 0x62, 0x7c, 0x25, 0x71, 0x9e, 0x89, 0x38, 0x31, 0x77,
	0x01, 0x69, 0x98, 0x2b, 0xad, 0x37, 0xcb, 0xa4, 0x11, 0x01, 0x3d, 0x00, 0x18, 0x15, 0x7a, 0xf4,
	0x2b, 0xe3, 0xe2, 0x1a, 0x49, 0xd3, 0x04, 0x9d, 0x8a, 0x64, 0x91, 0xa7, 0x68, 0x32, 0xc5, 0x98,
	0x04, 0x06, 0x1a, 0x0a, 0x8d, 0x52, 0xf0, 0xd4, 0xd5, 0xb4, 0x4f, 0x0f, 0xa1, 0x39, 0x15, 0x7c,
	0xc9, 0x93, 0x94, 0xcf, 0x52, 0x24, 0x07, 0x26, 0xf3, 0x3e, 0xd7, 0xfc, 0x22, 0x53, 0x8a, 0x1c,
	0x9a, 0x92, 0xa7, 0x82, 0x17, 0xfa, 0x06, 0x85, 0x4e, 0xe6, 0xdc, 0x6c, 0x43, 0xba, 0x3f, 0x02,
	0x98, 0xab, 0xc0, 0xbd, 0x4d, 0xf4, 0xbb, 0xf5, 0xf3, 0x41, 0xdf, 0xdb, 0xfd, 0x27, 0x3b, 0xcf,
	0xd6, 0xc9, 0xf1, 0xd3, 0x2f, 0x42, 0xb4, 0xf7, 0x99, 0x37, 0xab, 0xda, 0x47, 0xef, 0x8b, 0xff,
	0x02, 0x00, 0x00, 0xff, 0xff, 0xbe, 0xe1, 0xe6, 0xf9, 0x04, 0x07, 0x00, 0x00,
}
